/*
 * generated by Xtext 2.24.0
 */
package fr.inria.diverse.minijava_repl.xtext.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Assignment_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Block_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Expression_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.ForStatement_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.IfStatement_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Import_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Interpreter;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Method_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.Minijava_replPackage;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.TypeDeclaration_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.VariableDeclaration_Instruction;
import fr.inria.diverse.minijava_repl.xtext.minijava_repl.WhileStatement_Instruction;
import fr.inria.diverse.minijava_repl.xtext.services.MiniJava_replGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tetrabox.minijava.xtext.miniJava.And;
import org.tetrabox.minijava.xtext.miniJava.ArrayAccess;
import org.tetrabox.minijava.xtext.miniJava.ArrayLength;
import org.tetrabox.minijava.xtext.miniJava.ArrayTypeRef;
import org.tetrabox.minijava.xtext.miniJava.Assignment;
import org.tetrabox.minijava.xtext.miniJava.Block;
import org.tetrabox.minijava.xtext.miniJava.BoolConstant;
import org.tetrabox.minijava.xtext.miniJava.BooleanTypeRef;
import org.tetrabox.minijava.xtext.miniJava.ClassRef;
import org.tetrabox.minijava.xtext.miniJava.Clazz;
import org.tetrabox.minijava.xtext.miniJava.Division;
import org.tetrabox.minijava.xtext.miniJava.Equality;
import org.tetrabox.minijava.xtext.miniJava.Field;
import org.tetrabox.minijava.xtext.miniJava.FieldAccess;
import org.tetrabox.minijava.xtext.miniJava.ForStatement;
import org.tetrabox.minijava.xtext.miniJava.IfStatement;
import org.tetrabox.minijava.xtext.miniJava.Import;
import org.tetrabox.minijava.xtext.miniJava.Inequality;
import org.tetrabox.minijava.xtext.miniJava.Inferior;
import org.tetrabox.minijava.xtext.miniJava.InferiorOrEqual;
import org.tetrabox.minijava.xtext.miniJava.IntConstant;
import org.tetrabox.minijava.xtext.miniJava.IntegerTypeRef;
import org.tetrabox.minijava.xtext.miniJava.Interface;
import org.tetrabox.minijava.xtext.miniJava.Method;
import org.tetrabox.minijava.xtext.miniJava.MethodCall;
import org.tetrabox.minijava.xtext.miniJava.MiniJavaPackage;
import org.tetrabox.minijava.xtext.miniJava.Minus;
import org.tetrabox.minijava.xtext.miniJava.Modulo;
import org.tetrabox.minijava.xtext.miniJava.Multiplication;
import org.tetrabox.minijava.xtext.miniJava.NativeExpression;
import org.tetrabox.minijava.xtext.miniJava.Neg;
import org.tetrabox.minijava.xtext.miniJava.NewArray;
import org.tetrabox.minijava.xtext.miniJava.NewObject;
import org.tetrabox.minijava.xtext.miniJava.Not;
import org.tetrabox.minijava.xtext.miniJava.Null;
import org.tetrabox.minijava.xtext.miniJava.Or;
import org.tetrabox.minijava.xtext.miniJava.Plus;
import org.tetrabox.minijava.xtext.miniJava.PrintStatement;
import org.tetrabox.minijava.xtext.miniJava.Program;
import org.tetrabox.minijava.xtext.miniJava.Return;
import org.tetrabox.minijava.xtext.miniJava.StringConstant;
import org.tetrabox.minijava.xtext.miniJava.StringTypeRef;
import org.tetrabox.minijava.xtext.miniJava.Super;
import org.tetrabox.minijava.xtext.miniJava.Superior;
import org.tetrabox.minijava.xtext.miniJava.SuperiorOrEqual;
import org.tetrabox.minijava.xtext.miniJava.SymbolRef;
import org.tetrabox.minijava.xtext.miniJava.This;
import org.tetrabox.minijava.xtext.miniJava.VariableDeclaration;
import org.tetrabox.minijava.xtext.miniJava.VoidTypeRef;
import org.tetrabox.minijava.xtext.miniJava.WhileStatement;
import org.tetrabox.minijava.xtext.serializer.MiniJavaSemanticSequencer;

@SuppressWarnings("all")
public class MiniJava_replSemanticSequencer extends MiniJavaSemanticSequencer {

	@Inject
	private MiniJava_replGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniJavaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniJavaPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_ACCESS:
				sequence_ArrayAccess(context, (ArrayAccess) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_LENGTH:
				sequence_ArrayLength(context, (ArrayLength) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_TYPE_REF:
				sequence_TypeRef(context, (ArrayTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MiniJavaPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MiniJavaPackage.BOOL_CONSTANT:
				sequence_TerminalExpression(context, (BoolConstant) semanticObject); 
				return; 
			case MiniJavaPackage.BOOLEAN_TYPE_REF:
				sequence_SingleTypeRef(context, (BooleanTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.CLASS_REF:
				sequence_ClassRef(context, (ClassRef) semanticObject); 
				return; 
			case MiniJavaPackage.CLAZZ:
				sequence_Clazz(context, (Clazz) semanticObject); 
				return; 
			case MiniJavaPackage.DIVISION:
				sequence_MulOrDiv(context, (Division) semanticObject); 
				return; 
			case MiniJavaPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MiniJavaPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MiniJavaPackage.FIELD_ACCESS:
				sequence_SelectionExpression(context, (FieldAccess) semanticObject); 
				return; 
			case MiniJavaPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MiniJavaPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case MiniJavaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MiniJavaPackage.INEQUALITY:
				sequence_Equality(context, (Inequality) semanticObject); 
				return; 
			case MiniJavaPackage.INFERIOR:
				sequence_Comparison(context, (Inferior) semanticObject); 
				return; 
			case MiniJavaPackage.INFERIOR_OR_EQUAL:
				sequence_Comparison(context, (InferiorOrEqual) semanticObject); 
				return; 
			case MiniJavaPackage.INT_CONSTANT:
				sequence_TerminalExpression(context, (IntConstant) semanticObject); 
				return; 
			case MiniJavaPackage.INTEGER_TYPE_REF:
				sequence_SingleTypeRef(context, (IntegerTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case MiniJavaPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case MiniJavaPackage.METHOD_CALL:
				sequence_SelectionExpression(context, (MethodCall) semanticObject); 
				return; 
			case MiniJavaPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case MiniJavaPackage.MODULO:
				sequence_Modulo(context, (Modulo) semanticObject); 
				return; 
			case MiniJavaPackage.MULTIPLICATION:
				sequence_MulOrDiv(context, (Multiplication) semanticObject); 
				return; 
			case MiniJavaPackage.NATIVE_EXPRESSION:
				sequence_TerminalExpression(context, (NativeExpression) semanticObject); 
				return; 
			case MiniJavaPackage.NEG:
				sequence_Primary(context, (Neg) semanticObject); 
				return; 
			case MiniJavaPackage.NEW_ARRAY:
				sequence_TerminalExpression(context, (NewArray) semanticObject); 
				return; 
			case MiniJavaPackage.NEW_OBJECT:
				sequence_TerminalExpression(context, (NewObject) semanticObject); 
				return; 
			case MiniJavaPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case MiniJavaPackage.NULL:
				sequence_TerminalExpression(context, (Null) semanticObject); 
				return; 
			case MiniJavaPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MiniJavaPackage.PARAMETER:
				sequence_Parameter(context, (org.tetrabox.minijava.xtext.miniJava.Parameter) semanticObject); 
				return; 
			case MiniJavaPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case MiniJavaPackage.PRINT_STATEMENT:
				sequence_PrintStatement(context, (PrintStatement) semanticObject); 
				return; 
			case MiniJavaPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MiniJavaPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case MiniJavaPackage.STRING_CONSTANT:
				sequence_TerminalExpression(context, (StringConstant) semanticObject); 
				return; 
			case MiniJavaPackage.STRING_TYPE_REF:
				sequence_SingleTypeRef(context, (StringTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.SUPER:
				sequence_TerminalExpression(context, (Super) semanticObject); 
				return; 
			case MiniJavaPackage.SUPERIOR:
				sequence_Comparison(context, (Superior) semanticObject); 
				return; 
			case MiniJavaPackage.SUPERIOR_OR_EQUAL:
				sequence_Comparison(context, (SuperiorOrEqual) semanticObject); 
				return; 
			case MiniJavaPackage.SYMBOL_REF:
				sequence_TerminalExpression(context, (SymbolRef) semanticObject); 
				return; 
			case MiniJavaPackage.THIS:
				sequence_TerminalExpression(context, (This) semanticObject); 
				return; 
			case MiniJavaPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case MiniJavaPackage.VOID_TYPE_REF:
				sequence_SingleTypeRef(context, (VoidTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		else if (epackage == Minijava_replPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Minijava_replPackage.ASSIGNMENT_INSTRUCTION:
				sequence_InterpretableInstruction(context, (Assignment_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.BLOCK_INSTRUCTION:
				sequence_InterpretableInstruction(context, (Block_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.EXPRESSION_INSTRUCTION:
				sequence_InterpretableInstruction(context, (Expression_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.FOR_STATEMENT_INSTRUCTION:
				sequence_InterpretableInstruction(context, (ForStatement_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.IF_STATEMENT_INSTRUCTION:
				sequence_InterpretableInstruction(context, (IfStatement_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.IMPORT_INSTRUCTION:
				sequence_InterpretableInstruction(context, (Import_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.INTERPRETER:
				sequence_Interpreter(context, (Interpreter) semanticObject); 
				return; 
			case Minijava_replPackage.METHOD_INSTRUCTION:
				sequence_InterpretableInstruction(context, (Method_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.TYPE_DECLARATION_INSTRUCTION:
				sequence_InterpretableInstruction(context, (TypeDeclaration_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.VARIABLE_DECLARATION_INSTRUCTION:
				sequence_InterpretableInstruction(context, (VariableDeclaration_Instruction) semanticObject); 
				return; 
			case Minijava_replPackage.WHILE_STATEMENT_INSTRUCTION:
				sequence_InterpretableInstruction(context, (WhileStatement_Instruction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EntryPoint returns Assignment_Instruction
	 *     InterpretableInstruction returns Assignment_Instruction
	 *
	 * Constraint:
	 *     original=Assignment
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, Assignment_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.ASSIGNMENT_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.ASSIGNMENT_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalAssignmentParserRuleCall_4_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns Block_Instruction
	 *     InterpretableInstruction returns Block_Instruction
	 *
	 * Constraint:
	 *     original=Block
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, Block_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.BLOCK_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.BLOCK_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalBlockParserRuleCall_2_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns Expression_Instruction
	 *     InterpretableInstruction returns Expression_Instruction
	 *
	 * Constraint:
	 *     original=Expression
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, Expression_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.EXPRESSION_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.EXPRESSION_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalExpressionParserRuleCall_9_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns ForStatement_Instruction
	 *     InterpretableInstruction returns ForStatement_Instruction
	 *
	 * Constraint:
	 *     original=ForStatement
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, ForStatement_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.FOR_STATEMENT_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.FOR_STATEMENT_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalForStatementParserRuleCall_5_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns IfStatement_Instruction
	 *     InterpretableInstruction returns IfStatement_Instruction
	 *
	 * Constraint:
	 *     original=IfStatement
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, IfStatement_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.IF_STATEMENT_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.IF_STATEMENT_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalIfStatementParserRuleCall_6_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns Import_Instruction
	 *     InterpretableInstruction returns Import_Instruction
	 *
	 * Constraint:
	 *     original=Import
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, Import_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.IMPORT_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.IMPORT_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalImportParserRuleCall_1_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns Method_Instruction
	 *     InterpretableInstruction returns Method_Instruction
	 *
	 * Constraint:
	 *     original=Method
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, Method_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.METHOD_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.METHOD_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalMethodParserRuleCall_8_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns TypeDeclaration_Instruction
	 *     InterpretableInstruction returns TypeDeclaration_Instruction
	 *
	 * Constraint:
	 *     original=TypeDeclaration
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, TypeDeclaration_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.TYPE_DECLARATION_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.TYPE_DECLARATION_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalTypeDeclarationParserRuleCall_0_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns VariableDeclaration_Instruction
	 *     InterpretableInstruction returns VariableDeclaration_Instruction
	 *
	 * Constraint:
	 *     original=VariableDeclaration
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, VariableDeclaration_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.VARIABLE_DECLARATION_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.VARIABLE_DECLARATION_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalVariableDeclarationParserRuleCall_3_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns WhileStatement_Instruction
	 *     InterpretableInstruction returns WhileStatement_Instruction
	 *
	 * Constraint:
	 *     original=WhileStatement
	 */
	protected void sequence_InterpretableInstruction(ISerializationContext context, WhileStatement_Instruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Minijava_replPackage.Literals.WHILE_STATEMENT_INSTRUCTION__ORIGINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Minijava_replPackage.Literals.WHILE_STATEMENT_INSTRUCTION__ORIGINAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterpretableInstructionAccess().getOriginalWhileStatementParserRuleCall_7_1_0(), semanticObject.getOriginal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns Interpreter
	 *     Interpreter returns Interpreter
	 *
	 * Constraint:
	 *     {Interpreter}
	 */
	protected void sequence_Interpreter(ISerializationContext context, Interpreter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
