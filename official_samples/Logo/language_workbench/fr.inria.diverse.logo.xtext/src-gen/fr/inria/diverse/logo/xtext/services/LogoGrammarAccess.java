/*
 * generated by Xtext 2.14.0-SNAPSHOT
 */
package fr.inria.diverse.logo.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LogoGrammarAccess extends AbstractGrammarElementFinder {
	
	public class LogoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Logo");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//Logo returns logo::Logo:
		//	statements+=Statement+;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=Statement+
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Parameter returns logo::Parameter:
		//	':' name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//':' name=ID
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRightParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLeftParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cForwardParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPenDownParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPenUpParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cProcedureDefinitionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cProcedureCallParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cControlStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cBlockParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//Statement returns logo::Statement:
		//	Right | Left | Forward | PenDown | PenUp | ProcedureDefinition | ProcedureCall | ControlStatement | Block;
		@Override public ParserRule getRule() { return rule; }
		
		//Right | Left | Forward | PenDown | PenUp | ProcedureDefinition | ProcedureCall | ControlStatement | Block
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Right
		public RuleCall getRightParserRuleCall_0() { return cRightParserRuleCall_0; }
		
		//Left
		public RuleCall getLeftParserRuleCall_1() { return cLeftParserRuleCall_1; }
		
		//Forward
		public RuleCall getForwardParserRuleCall_2() { return cForwardParserRuleCall_2; }
		
		//PenDown
		public RuleCall getPenDownParserRuleCall_3() { return cPenDownParserRuleCall_3; }
		
		//PenUp
		public RuleCall getPenUpParserRuleCall_4() { return cPenUpParserRuleCall_4; }
		
		//ProcedureDefinition
		public RuleCall getProcedureDefinitionParserRuleCall_5() { return cProcedureDefinitionParserRuleCall_5; }
		
		//ProcedureCall
		public RuleCall getProcedureCallParserRuleCall_6() { return cProcedureCallParserRuleCall_6; }
		
		//ControlStatement
		public RuleCall getControlStatementParserRuleCall_7() { return cControlStatementParserRuleCall_7; }
		
		//Block
		public RuleCall getBlockParserRuleCall_8() { return cBlockParserRuleCall_8; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEqualsGreaterLowerParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExtendedExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Expression returns logo::Expression:
		//	EqualsGreaterLower | ExtendedExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//EqualsGreaterLower | ExtendedExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EqualsGreaterLower
		public RuleCall getEqualsGreaterLowerParserRuleCall_0() { return cEqualsGreaterLowerParserRuleCall_0; }
		
		//ExtendedExpression
		public RuleCall getExtendedExpressionParserRuleCall_1() { return cExtendedExpressionParserRuleCall_1; }
	}
	public class ExtendedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.ExtendedExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAndParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ExtendedExpression returns expression::ExtendedExpression:
		//	Or | And;
		@Override public ParserRule getRule() { return rule; }
		
		//Or | And
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//And
		public RuleCall getAndParserRuleCall_1() { return cAndParserRuleCall_1; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Constant returns expression::Constant:
		//	IntValue | BoolValue;
		@Override public ParserRule getRule() { return rule; }
		
		//IntValue | BoolValue
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntValue
		public RuleCall getIntValueParserRuleCall_0() { return cIntValueParserRuleCall_0; }
		
		//BoolValue
		public RuleCall getBoolValueParserRuleCall_1() { return cBoolValueParserRuleCall_1; }
	}
	public class RightElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Right");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRightKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAngleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAngleExpressionParserRuleCall_1_0 = (RuleCall)cAngleAssignment_1.eContents().get(0);
		
		//Right returns statement::Right:
		//	'right' angle=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'right' angle=Expression
		public Group getGroup() { return cGroup; }
		
		//'right'
		public Keyword getRightKeyword_0() { return cRightKeyword_0; }
		
		//angle=Expression
		public Assignment getAngleAssignment_1() { return cAngleAssignment_1; }
		
		//Expression
		public RuleCall getAngleExpressionParserRuleCall_1_0() { return cAngleExpressionParserRuleCall_1_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAngleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAngleExpressionParserRuleCall_1_0 = (RuleCall)cAngleAssignment_1.eContents().get(0);
		
		//Left returns statement::Left:
		//	'left' angle=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'left' angle=Expression
		public Group getGroup() { return cGroup; }
		
		//'left'
		public Keyword getLeftKeyword_0() { return cLeftKeyword_0; }
		
		//angle=Expression
		public Assignment getAngleAssignment_1() { return cAngleAssignment_1; }
		
		//Expression
		public RuleCall getAngleExpressionParserRuleCall_1_0() { return cAngleExpressionParserRuleCall_1_0; }
	}
	public class ForwardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Forward");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForwardKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStepExpressionParserRuleCall_1_0 = (RuleCall)cStepAssignment_1.eContents().get(0);
		
		//Forward returns statement::Forward:
		//	'forward' step=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'forward' step=Expression
		public Group getGroup() { return cGroup; }
		
		//'forward'
		public Keyword getForwardKeyword_0() { return cForwardKeyword_0; }
		
		//step=Expression
		public Assignment getStepAssignment_1() { return cStepAssignment_1; }
		
		//Expression
		public RuleCall getStepExpressionParserRuleCall_1_0() { return cStepExpressionParserRuleCall_1_0; }
	}
	public class PenDownElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.PenDown");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPenDownAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPendownKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PenDown returns statement::PenDown:
		//	{statement::PenDown}
		//	'pendown';
		@Override public ParserRule getRule() { return rule; }
		
		//{statement::PenDown} 'pendown'
		public Group getGroup() { return cGroup; }
		
		//{statement::PenDown}
		public Action getPenDownAction_0() { return cPenDownAction_0; }
		
		//'pendown'
		public Keyword getPendownKeyword_1() { return cPendownKeyword_1; }
	}
	public class PenUpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.PenUp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPenUpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPenupKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PenUp returns statement::PenUp:
		//	{statement::PenUp}
		//	'penup';
		@Override public ParserRule getRule() { return rule; }
		
		//{statement::PenUp} 'penup'
		public Group getGroup() { return cGroup; }
		
		//{statement::PenUp}
		public Action getPenUpAction_0() { return cPenUpAction_0; }
		
		//'penup'
		public Keyword getPenupKeyword_1() { return cPenupKeyword_1; }
	}
	public class ProcedureDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.ProcedureDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersParameterParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ProcedureDefinition returns statement::ProcedureDefinition:
		//	'to' name=ID parameters+=Parameter* statements+=Statement+ 'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'to' name=ID parameters+=Parameter* statements+=Statement+ 'end'
		public Group getGroup() { return cGroup; }
		
		//'to'
		public Keyword getToKeyword_0() { return cToKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//parameters+=Parameter*
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_0() { return cParametersParameterParserRuleCall_2_0; }
		
		//statements+=Statement+
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0() { return cStatementsStatementParserRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class ProcedureCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.ProcedureCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDefinitionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDefinitionProcedureDefinitionCrossReference_0_0 = (CrossReference)cDefinitionAssignment_0.eContents().get(0);
		private final RuleCall cDefinitionProcedureDefinitionIDTerminalRuleCall_0_0_1 = (RuleCall)cDefinitionProcedureDefinitionCrossReference_0_0.eContents().get(1);
		private final Assignment cParameterValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParameterValuesExpressionParserRuleCall_1_0 = (RuleCall)cParameterValuesAssignment_1.eContents().get(0);
		
		//ProcedureCall returns statement::ProcedureCall:
		//	definition=[statement::ProcedureDefinition] parameterValues+=Expression*;
		@Override public ParserRule getRule() { return rule; }
		
		//definition=[statement::ProcedureDefinition] parameterValues+=Expression*
		public Group getGroup() { return cGroup; }
		
		//definition=[statement::ProcedureDefinition]
		public Assignment getDefinitionAssignment_0() { return cDefinitionAssignment_0; }
		
		//[statement::ProcedureDefinition]
		public CrossReference getDefinitionProcedureDefinitionCrossReference_0_0() { return cDefinitionProcedureDefinitionCrossReference_0_0; }
		
		//ID
		public RuleCall getDefinitionProcedureDefinitionIDTerminalRuleCall_0_0_1() { return cDefinitionProcedureDefinitionIDTerminalRuleCall_0_0_1; }
		
		//parameterValues+=Expression*
		public Assignment getParameterValuesAssignment_1() { return cParameterValuesAssignment_1; }
		
		//Expression
		public RuleCall getParameterValuesExpressionParserRuleCall_1_0() { return cParameterValuesExpressionParserRuleCall_1_0; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Block returns statement::Block:
		//	'[' statements+=Statement+ ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' statements+=Statement+ ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//statements+=Statement+
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_0() { return cStatementsStatementParserRuleCall_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ControlStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.ControlStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfElseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRepeatParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ControlStatement returns statement::ControlStatement:
		//	If | IfElse | While | Repeat;
		@Override public ParserRule getRule() { return rule; }
		
		//If | IfElse | While | Repeat
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//If
		public RuleCall getIfParserRuleCall_0() { return cIfParserRuleCall_0; }
		
		//IfElse
		public RuleCall getIfElseParserRuleCall_1() { return cIfElseParserRuleCall_1; }
		
		//While
		public RuleCall getWhileParserRuleCall_2() { return cWhileParserRuleCall_2; }
		
		//Repeat
		public RuleCall getRepeatParserRuleCall_3() { return cRepeatParserRuleCall_3; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_1_0_0 = (RuleCall)cConditionAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cConditionAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		private final Assignment cIfBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfBlockBlockParserRuleCall_2_0 = (RuleCall)cIfBlockAssignment_2.eContents().get(0);
		
		//If returns control::If:
		//	'if' (condition=Expression | '[' condition=Expression ']') ifBlock=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' (condition=Expression | '[' condition=Expression ']') ifBlock=Block
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//condition=Expression | '[' condition=Expression ']'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0_0() { return cConditionExpressionParserRuleCall_1_0_0; }
		
		//'[' condition=Expression ']'
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1_0() { return cLeftSquareBracketKeyword_1_1_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_1_1() { return cConditionAssignment_1_1_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_1_1_0() { return cConditionExpressionParserRuleCall_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1_2() { return cRightSquareBracketKeyword_1_1_2; }
		
		//ifBlock=Block
		public Assignment getIfBlockAssignment_2() { return cIfBlockAssignment_2; }
		
		//Block
		public RuleCall getIfBlockBlockParserRuleCall_2_0() { return cIfBlockBlockParserRuleCall_2_0; }
	}
	public class IfElseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.IfElse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfelseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_1_0_0 = (RuleCall)cConditionAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cConditionAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		private final Assignment cIfBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIfBlockBlockParserRuleCall_2_0 = (RuleCall)cIfBlockAssignment_2.eContents().get(0);
		private final Assignment cElseBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElseBlockBlockParserRuleCall_3_0 = (RuleCall)cElseBlockAssignment_3.eContents().get(0);
		
		//IfElse returns control::If:
		//	'ifelse' (condition=Expression | '[' condition=Expression ']') ifBlock=Block elseBlock=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//'ifelse' (condition=Expression | '[' condition=Expression ']') ifBlock=Block elseBlock=Block
		public Group getGroup() { return cGroup; }
		
		//'ifelse'
		public Keyword getIfelseKeyword_0() { return cIfelseKeyword_0; }
		
		//condition=Expression | '[' condition=Expression ']'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0_0() { return cConditionExpressionParserRuleCall_1_0_0; }
		
		//'[' condition=Expression ']'
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1_0() { return cLeftSquareBracketKeyword_1_1_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_1_1() { return cConditionAssignment_1_1_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_1_1_0() { return cConditionExpressionParserRuleCall_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1_2() { return cRightSquareBracketKeyword_1_1_2; }
		
		//ifBlock=Block
		public Assignment getIfBlockAssignment_2() { return cIfBlockAssignment_2; }
		
		//Block
		public RuleCall getIfBlockBlockParserRuleCall_2_0() { return cIfBlockBlockParserRuleCall_2_0; }
		
		//elseBlock=Block
		public Assignment getElseBlockAssignment_3() { return cElseBlockAssignment_3; }
		
		//Block
		public RuleCall getElseBlockBlockParserRuleCall_3_0() { return cElseBlockBlockParserRuleCall_3_0; }
	}
	public class WhileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.While");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cConditionExpressionParserRuleCall_1_0_0 = (RuleCall)cConditionAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cConditionAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		private final Assignment cBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBlockBlockParserRuleCall_2_0 = (RuleCall)cBlockAssignment_2.eContents().get(0);
		
		//While returns control::While:
		//	'while' (condition=Expression | '[' condition=Expression ']') block=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//'while' (condition=Expression | '[' condition=Expression ']') block=Block
		public Group getGroup() { return cGroup; }
		
		//'while'
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }
		
		//condition=Expression | '[' condition=Expression ']'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0_0() { return cConditionExpressionParserRuleCall_1_0_0; }
		
		//'[' condition=Expression ']'
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1_0() { return cLeftSquareBracketKeyword_1_1_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1_1_1() { return cConditionAssignment_1_1_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_1_1_0() { return cConditionExpressionParserRuleCall_1_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1_2() { return cRightSquareBracketKeyword_1_1_2; }
		
		//block=Block
		public Assignment getBlockAssignment_2() { return cBlockAssignment_2; }
		
		//Block
		public RuleCall getBlockBlockParserRuleCall_2_0() { return cBlockBlockParserRuleCall_2_0; }
	}
	public class RepeatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Repeat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepeatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBlockBlockParserRuleCall_2_0 = (RuleCall)cBlockAssignment_2.eContents().get(0);
		
		//Repeat returns control::Repeat:
		//	'repeat' condition=Expression block=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//'repeat' condition=Expression block=Block
		public Group getGroup() { return cGroup; }
		
		//'repeat'
		public Keyword getRepeatKeyword_0() { return cRepeatKeyword_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
		
		//block=Block
		public Assignment getBlockAssignment_2() { return cBlockAssignment_2; }
		
		//Block
		public RuleCall getBlockBlockParserRuleCall_2_0() { return cBlockBlockParserRuleCall_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsEqualsGreaterLowerParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsEqualsGreaterLowerParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		
		//And returns extended::And:
		//	'and' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'and' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+
		public Group getGroup() { return cGroup; }
		
		//'and'
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }
		
		//expressions+=EqualsGreaterLower
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }
		
		//EqualsGreaterLower
		public RuleCall getExpressionsEqualsGreaterLowerParserRuleCall_1_0() { return cExpressionsEqualsGreaterLowerParserRuleCall_1_0; }
		
		//=> (expressions+=EqualsGreaterLower)+
		public Group getGroup_2() { return cGroup_2; }
		
		//expressions+=EqualsGreaterLower
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }
		
		//EqualsGreaterLower
		public RuleCall getExpressionsEqualsGreaterLowerParserRuleCall_2_0_0() { return cExpressionsEqualsGreaterLowerParserRuleCall_2_0_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionsEqualsGreaterLowerParserRuleCall_1_0 = (RuleCall)cExpressionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cExpressionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionsEqualsGreaterLowerParserRuleCall_2_0_0 = (RuleCall)cExpressionsAssignment_2_0.eContents().get(0);
		
		//Or returns extended::Or:
		//	'or' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'or' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+
		public Group getGroup() { return cGroup; }
		
		//'or'
		public Keyword getOrKeyword_0() { return cOrKeyword_0; }
		
		//expressions+=EqualsGreaterLower
		public Assignment getExpressionsAssignment_1() { return cExpressionsAssignment_1; }
		
		//EqualsGreaterLower
		public RuleCall getExpressionsEqualsGreaterLowerParserRuleCall_1_0() { return cExpressionsEqualsGreaterLowerParserRuleCall_1_0; }
		
		//=> (expressions+=EqualsGreaterLower)+
		public Group getGroup_2() { return cGroup_2; }
		
		//expressions+=EqualsGreaterLower
		public Assignment getExpressionsAssignment_2_0() { return cExpressionsAssignment_2_0; }
		
		//EqualsGreaterLower
		public RuleCall getExpressionsEqualsGreaterLowerParserRuleCall_2_0_0() { return cExpressionsEqualsGreaterLowerParserRuleCall_2_0_0; }
	}
	public class EqualsGreaterLowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.EqualsGreaterLower");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cEqualsLeftExpressionAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cGreaterLeftExpressionAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cLowerLeftExpressionAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionPlusMinusParserRuleCall_1_1_0 = (RuleCall)cRightExpressionAssignment_1_1.eContents().get(0);
		
		//EqualsGreaterLower returns logo::Expression:
		//	PlusMinus (({binary::Equals.leftExpression=current} '='
		//	| {binary::Greater.leftExpression=current} '>'
		//	| {binary::Lower.leftExpression=current} '<') rightExpression=PlusMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PlusMinus (({binary::Equals.leftExpression=current} '=' | {binary::Greater.leftExpression=current} '>' |
		//{binary::Lower.leftExpression=current} '<') rightExpression=PlusMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusMinus
		public RuleCall getPlusMinusParserRuleCall_0() { return cPlusMinusParserRuleCall_0; }
		
		//(({binary::Equals.leftExpression=current} '=' | {binary::Greater.leftExpression=current} '>' |
		//{binary::Lower.leftExpression=current} '<') rightExpression=PlusMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{binary::Equals.leftExpression=current} '=' | {binary::Greater.leftExpression=current} '>' |
		//{binary::Lower.leftExpression=current} '<'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{binary::Equals.leftExpression=current} '='
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{binary::Equals.leftExpression=current}
		public Action getEqualsLeftExpressionAction_1_0_0_0() { return cEqualsLeftExpressionAction_1_0_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0_0_1() { return cEqualsSignKeyword_1_0_0_1; }
		
		//{binary::Greater.leftExpression=current} '>'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{binary::Greater.leftExpression=current}
		public Action getGreaterLeftExpressionAction_1_0_1_0() { return cGreaterLeftExpressionAction_1_0_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_0_1_1() { return cGreaterThanSignKeyword_1_0_1_1; }
		
		//{binary::Lower.leftExpression=current} '<'
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }
		
		//{binary::Lower.leftExpression=current}
		public Action getLowerLeftExpressionAction_1_0_2_0() { return cLowerLeftExpressionAction_1_0_2_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0_2_1() { return cLessThanSignKeyword_1_0_2_1; }
		
		//rightExpression=PlusMinus
		public Assignment getRightExpressionAssignment_1_1() { return cRightExpressionAssignment_1_1; }
		
		//PlusMinus
		public RuleCall getRightExpressionPlusMinusParserRuleCall_1_1_0() { return cRightExpressionPlusMinusParserRuleCall_1_1_0; }
	}
	public class PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.PlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_0_0 = (Group)cAlternatives_1_0_0.eContents().get(0);
		private final Action cPlusLeftExpressionAction_1_0_0_0_0 = (Action)cGroup_1_0_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_0_1 = (Keyword)cGroup_1_0_0_0.eContents().get(1);
		private final Group cGroup_1_0_0_1 = (Group)cAlternatives_1_0_0.eContents().get(1);
		private final Action cMinusLeftExpressionAction_1_0_0_1_0 = (Action)cGroup_1_0_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_0_1_1 = (Keyword)cGroup_1_0_0_1.eContents().get(1);
		private final Assignment cRightExpressionAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cRightExpressionMultDivParserRuleCall_1_0_1_0 = (RuleCall)cRightExpressionAssignment_1_0_1.eContents().get(0);
		
		//PlusMinus returns logo::Expression:
		//	MultDiv => (({binary::Plus.leftExpression=current} '+'
		//	| {binary::Minus.leftExpression=current} '-') rightExpression=MultDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultDiv => (({binary::Plus.leftExpression=current} '+' | {binary::Minus.leftExpression=current} '-')
		//rightExpression=MultDiv)*
		public Group getGroup() { return cGroup; }
		
		//MultDiv
		public RuleCall getMultDivParserRuleCall_0() { return cMultDivParserRuleCall_0; }
		
		//=> (({binary::Plus.leftExpression=current} '+' | {binary::Minus.leftExpression=current} '-') rightExpression=MultDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({binary::Plus.leftExpression=current} '+' | {binary::Minus.leftExpression=current} '-') rightExpression=MultDiv
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{binary::Plus.leftExpression=current} '+' | {binary::Minus.leftExpression=current} '-'
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }
		
		//{binary::Plus.leftExpression=current} '+'
		public Group getGroup_1_0_0_0() { return cGroup_1_0_0_0; }
		
		//{binary::Plus.leftExpression=current}
		public Action getPlusLeftExpressionAction_1_0_0_0_0() { return cPlusLeftExpressionAction_1_0_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_0_1() { return cPlusSignKeyword_1_0_0_0_1; }
		
		//{binary::Minus.leftExpression=current} '-'
		public Group getGroup_1_0_0_1() { return cGroup_1_0_0_1; }
		
		//{binary::Minus.leftExpression=current}
		public Action getMinusLeftExpressionAction_1_0_0_1_0() { return cMinusLeftExpressionAction_1_0_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_0_1_1() { return cHyphenMinusKeyword_1_0_0_1_1; }
		
		//rightExpression=MultDiv
		public Assignment getRightExpressionAssignment_1_0_1() { return cRightExpressionAssignment_1_0_1; }
		
		//MultDiv
		public RuleCall getRightExpressionMultDivParserRuleCall_1_0_1_0() { return cRightExpressionMultDivParserRuleCall_1_0_1_0; }
	}
	public class MultDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.MultDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotOppositeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultLeftExpressionAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftExpressionAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightExpressionNotOppositeParserRuleCall_1_1_0 = (RuleCall)cRightExpressionAssignment_1_1.eContents().get(0);
		
		//MultDiv returns logo::Expression:
		//	NotOpposite (({binary::Mult.leftExpression=current} '*'
		//	| {binary::Div.leftExpression=current} '/') rightExpression=NotOpposite)*;
		@Override public ParserRule getRule() { return rule; }
		
		//NotOpposite (({binary::Mult.leftExpression=current} '*' | {binary::Div.leftExpression=current} '/')
		//rightExpression=NotOpposite)*
		public Group getGroup() { return cGroup; }
		
		//NotOpposite
		public RuleCall getNotOppositeParserRuleCall_0() { return cNotOppositeParserRuleCall_0; }
		
		//(({binary::Mult.leftExpression=current} '*' | {binary::Div.leftExpression=current} '/') rightExpression=NotOpposite)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{binary::Mult.leftExpression=current} '*' | {binary::Div.leftExpression=current} '/'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{binary::Mult.leftExpression=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{binary::Mult.leftExpression=current}
		public Action getMultLeftExpressionAction_1_0_0_0() { return cMultLeftExpressionAction_1_0_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }
		
		//{binary::Div.leftExpression=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{binary::Div.leftExpression=current}
		public Action getDivLeftExpressionAction_1_0_1_0() { return cDivLeftExpressionAction_1_0_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }
		
		//rightExpression=NotOpposite
		public Assignment getRightExpressionAssignment_1_1() { return cRightExpressionAssignment_1_1; }
		
		//NotOpposite
		public RuleCall getRightExpressionNotOppositeParserRuleCall_1_1_0() { return cRightExpressionNotOppositeParserRuleCall_1_1_0; }
	}
	public class NotOppositeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.NotOpposite");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableReadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cNotAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cNotKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cExpressionAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExpressionNotOppositeParserRuleCall_3_2_0 = (RuleCall)cExpressionAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cOppositeAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cExpressionAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExpressionNotOppositeParserRuleCall_4_2_0 = (RuleCall)cExpressionAssignment_4_2.eContents().get(0);
		
		//NotOpposite returns logo::Expression:
		//	Constant | VariableRead | '(' Expression ')' | {unary::Not} 'not' expression=NotOpposite | {unary::Opposite} '-'
		//	expression=NotOpposite;
		@Override public ParserRule getRule() { return rule; }
		
		//Constant | VariableRead | '(' Expression ')' | {unary::Not} 'not' expression=NotOpposite | {unary::Opposite} '-'
		//expression=NotOpposite
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }
		
		//VariableRead
		public RuleCall getVariableReadParserRuleCall_1() { return cVariableReadParserRuleCall_1; }
		
		//'(' Expression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2_1() { return cExpressionParserRuleCall_2_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//{unary::Not} 'not' expression=NotOpposite
		public Group getGroup_3() { return cGroup_3; }
		
		//{unary::Not}
		public Action getNotAction_3_0() { return cNotAction_3_0; }
		
		//'not'
		public Keyword getNotKeyword_3_1() { return cNotKeyword_3_1; }
		
		//expression=NotOpposite
		public Assignment getExpressionAssignment_3_2() { return cExpressionAssignment_3_2; }
		
		//NotOpposite
		public RuleCall getExpressionNotOppositeParserRuleCall_3_2_0() { return cExpressionNotOppositeParserRuleCall_3_2_0; }
		
		//{unary::Opposite} '-' expression=NotOpposite
		public Group getGroup_4() { return cGroup_4; }
		
		//{unary::Opposite}
		public Action getOppositeAction_4_0() { return cOppositeAction_4_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_4_1() { return cHyphenMinusKeyword_4_1; }
		
		//expression=NotOpposite
		public Assignment getExpressionAssignment_4_2() { return cExpressionAssignment_4_2; }
		
		//NotOpposite
		public RuleCall getExpressionNotOppositeParserRuleCall_4_2_0() { return cExpressionNotOppositeParserRuleCall_4_2_0; }
	}
	public class VariableReadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.VariableRead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//VariableRead returns expression::VariableRead:
		//	':' name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//':' name=ID
		public Group getGroup() { return cGroup; }
		
		//':'
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class IntValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.IntValue");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntValue returns constant::IntValue:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class BoolValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.logo.xtext.Logo.BoolValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_1_0_0 = (Keyword)cValueAssignment_1_0.eContents().get(0);
		private final Keyword cFalseKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//BoolValue returns constant::BoolValue:
		//	{constant::BoolValue} (value?='true' | 'false');
		@Override public ParserRule getRule() { return rule; }
		
		//{constant::BoolValue} (value?='true' | 'false')
		public Group getGroup() { return cGroup; }
		
		//{constant::BoolValue}
		public Action getBoolValueAction_0() { return cBoolValueAction_0; }
		
		//value?='true' | 'false'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//value?='true'
		public Assignment getValueAssignment_1_0() { return cValueAssignment_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_1_0_0() { return cValueTrueKeyword_1_0_0; }
		
		//'false'
		public Keyword getFalseKeyword_1_1() { return cFalseKeyword_1_1; }
	}
	
	
	private final LogoElements pLogo;
	private final ParameterElements pParameter;
	private final StatementElements pStatement;
	private final ExpressionElements pExpression;
	private final ExtendedExpressionElements pExtendedExpression;
	private final ConstantElements pConstant;
	private final RightElements pRight;
	private final LeftElements pLeft;
	private final ForwardElements pForward;
	private final PenDownElements pPenDown;
	private final PenUpElements pPenUp;
	private final ProcedureDefinitionElements pProcedureDefinition;
	private final ProcedureCallElements pProcedureCall;
	private final BlockElements pBlock;
	private final ControlStatementElements pControlStatement;
	private final IfElements pIf;
	private final IfElseElements pIfElse;
	private final WhileElements pWhile;
	private final RepeatElements pRepeat;
	private final AndElements pAnd;
	private final OrElements pOr;
	private final EqualsGreaterLowerElements pEqualsGreaterLower;
	private final PlusMinusElements pPlusMinus;
	private final MultDivElements pMultDiv;
	private final NotOppositeElements pNotOpposite;
	private final VariableReadElements pVariableRead;
	private final IntValueElements pIntValue;
	private final BoolValueElements pBoolValue;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LogoGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pLogo = new LogoElements();
		this.pParameter = new ParameterElements();
		this.pStatement = new StatementElements();
		this.pExpression = new ExpressionElements();
		this.pExtendedExpression = new ExtendedExpressionElements();
		this.pConstant = new ConstantElements();
		this.pRight = new RightElements();
		this.pLeft = new LeftElements();
		this.pForward = new ForwardElements();
		this.pPenDown = new PenDownElements();
		this.pPenUp = new PenUpElements();
		this.pProcedureDefinition = new ProcedureDefinitionElements();
		this.pProcedureCall = new ProcedureCallElements();
		this.pBlock = new BlockElements();
		this.pControlStatement = new ControlStatementElements();
		this.pIf = new IfElements();
		this.pIfElse = new IfElseElements();
		this.pWhile = new WhileElements();
		this.pRepeat = new RepeatElements();
		this.pAnd = new AndElements();
		this.pOr = new OrElements();
		this.pEqualsGreaterLower = new EqualsGreaterLowerElements();
		this.pPlusMinus = new PlusMinusElements();
		this.pMultDiv = new MultDivElements();
		this.pNotOpposite = new NotOppositeElements();
		this.pVariableRead = new VariableReadElements();
		this.pIntValue = new IntValueElements();
		this.pBoolValue = new BoolValueElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("fr.inria.diverse.logo.xtext.Logo".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Logo returns logo::Logo:
	//	statements+=Statement+;
	public LogoElements getLogoAccess() {
		return pLogo;
	}
	
	public ParserRule getLogoRule() {
		return getLogoAccess().getRule();
	}
	
	//Parameter returns logo::Parameter:
	//	':' name=ID;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Statement returns logo::Statement:
	//	Right | Left | Forward | PenDown | PenUp | ProcedureDefinition | ProcedureCall | ControlStatement | Block;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//Expression returns logo::Expression:
	//	EqualsGreaterLower | ExtendedExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//ExtendedExpression returns expression::ExtendedExpression:
	//	Or | And;
	public ExtendedExpressionElements getExtendedExpressionAccess() {
		return pExtendedExpression;
	}
	
	public ParserRule getExtendedExpressionRule() {
		return getExtendedExpressionAccess().getRule();
	}
	
	//Constant returns expression::Constant:
	//	IntValue | BoolValue;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//Right returns statement::Right:
	//	'right' angle=Expression;
	public RightElements getRightAccess() {
		return pRight;
	}
	
	public ParserRule getRightRule() {
		return getRightAccess().getRule();
	}
	
	//Left returns statement::Left:
	//	'left' angle=Expression;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Forward returns statement::Forward:
	//	'forward' step=Expression;
	public ForwardElements getForwardAccess() {
		return pForward;
	}
	
	public ParserRule getForwardRule() {
		return getForwardAccess().getRule();
	}
	
	//PenDown returns statement::PenDown:
	//	{statement::PenDown}
	//	'pendown';
	public PenDownElements getPenDownAccess() {
		return pPenDown;
	}
	
	public ParserRule getPenDownRule() {
		return getPenDownAccess().getRule();
	}
	
	//PenUp returns statement::PenUp:
	//	{statement::PenUp}
	//	'penup';
	public PenUpElements getPenUpAccess() {
		return pPenUp;
	}
	
	public ParserRule getPenUpRule() {
		return getPenUpAccess().getRule();
	}
	
	//ProcedureDefinition returns statement::ProcedureDefinition:
	//	'to' name=ID parameters+=Parameter* statements+=Statement+ 'end';
	public ProcedureDefinitionElements getProcedureDefinitionAccess() {
		return pProcedureDefinition;
	}
	
	public ParserRule getProcedureDefinitionRule() {
		return getProcedureDefinitionAccess().getRule();
	}
	
	//ProcedureCall returns statement::ProcedureCall:
	//	definition=[statement::ProcedureDefinition] parameterValues+=Expression*;
	public ProcedureCallElements getProcedureCallAccess() {
		return pProcedureCall;
	}
	
	public ParserRule getProcedureCallRule() {
		return getProcedureCallAccess().getRule();
	}
	
	//Block returns statement::Block:
	//	'[' statements+=Statement+ ']';
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//ControlStatement returns statement::ControlStatement:
	//	If | IfElse | While | Repeat;
	public ControlStatementElements getControlStatementAccess() {
		return pControlStatement;
	}
	
	public ParserRule getControlStatementRule() {
		return getControlStatementAccess().getRule();
	}
	
	//If returns control::If:
	//	'if' (condition=Expression | '[' condition=Expression ']') ifBlock=Block;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//IfElse returns control::If:
	//	'ifelse' (condition=Expression | '[' condition=Expression ']') ifBlock=Block elseBlock=Block;
	public IfElseElements getIfElseAccess() {
		return pIfElse;
	}
	
	public ParserRule getIfElseRule() {
		return getIfElseAccess().getRule();
	}
	
	//While returns control::While:
	//	'while' (condition=Expression | '[' condition=Expression ']') block=Block;
	public WhileElements getWhileAccess() {
		return pWhile;
	}
	
	public ParserRule getWhileRule() {
		return getWhileAccess().getRule();
	}
	
	//Repeat returns control::Repeat:
	//	'repeat' condition=Expression block=Block;
	public RepeatElements getRepeatAccess() {
		return pRepeat;
	}
	
	public ParserRule getRepeatRule() {
		return getRepeatAccess().getRule();
	}
	
	//And returns extended::And:
	//	'and' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Or returns extended::Or:
	//	'or' expressions+=EqualsGreaterLower => (expressions+=EqualsGreaterLower)+;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//EqualsGreaterLower returns logo::Expression:
	//	PlusMinus (({binary::Equals.leftExpression=current} '='
	//	| {binary::Greater.leftExpression=current} '>'
	//	| {binary::Lower.leftExpression=current} '<') rightExpression=PlusMinus)*;
	public EqualsGreaterLowerElements getEqualsGreaterLowerAccess() {
		return pEqualsGreaterLower;
	}
	
	public ParserRule getEqualsGreaterLowerRule() {
		return getEqualsGreaterLowerAccess().getRule();
	}
	
	//PlusMinus returns logo::Expression:
	//	MultDiv => (({binary::Plus.leftExpression=current} '+'
	//	| {binary::Minus.leftExpression=current} '-') rightExpression=MultDiv)*;
	public PlusMinusElements getPlusMinusAccess() {
		return pPlusMinus;
	}
	
	public ParserRule getPlusMinusRule() {
		return getPlusMinusAccess().getRule();
	}
	
	//MultDiv returns logo::Expression:
	//	NotOpposite (({binary::Mult.leftExpression=current} '*'
	//	| {binary::Div.leftExpression=current} '/') rightExpression=NotOpposite)*;
	public MultDivElements getMultDivAccess() {
		return pMultDiv;
	}
	
	public ParserRule getMultDivRule() {
		return getMultDivAccess().getRule();
	}
	
	//NotOpposite returns logo::Expression:
	//	Constant | VariableRead | '(' Expression ')' | {unary::Not} 'not' expression=NotOpposite | {unary::Opposite} '-'
	//	expression=NotOpposite;
	public NotOppositeElements getNotOppositeAccess() {
		return pNotOpposite;
	}
	
	public ParserRule getNotOppositeRule() {
		return getNotOppositeAccess().getRule();
	}
	
	//VariableRead returns expression::VariableRead:
	//	':' name=ID;
	public VariableReadElements getVariableReadAccess() {
		return pVariableRead;
	}
	
	public ParserRule getVariableReadRule() {
		return getVariableReadAccess().getRule();
	}
	
	//IntValue returns constant::IntValue:
	//	value=INT;
	public IntValueElements getIntValueAccess() {
		return pIntValue;
	}
	
	public ParserRule getIntValueRule() {
		return getIntValueAccess().getRule();
	}
	
	//BoolValue returns constant::BoolValue:
	//	{constant::BoolValue} (value?='true' | 'false');
	public BoolValueElements getBoolValueAccess() {
		return pBoolValue;
	}
	
	public ParserRule getBoolValueRule() {
		return getBoolValueAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
