/*
 * generated by Xtext 2.14.0-SNAPSHOT
 */
package fr.inria.diverse.logo.xtext.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.logo.Logo;
import fr.inria.diverse.logo.LogoPackage;
import fr.inria.diverse.logo.expression.ExpressionPackage;
import fr.inria.diverse.logo.expression.VariableRead;
import fr.inria.diverse.logo.expression.binary.BinaryPackage;
import fr.inria.diverse.logo.expression.binary.Div;
import fr.inria.diverse.logo.expression.binary.Equals;
import fr.inria.diverse.logo.expression.binary.Greater;
import fr.inria.diverse.logo.expression.binary.Lower;
import fr.inria.diverse.logo.expression.binary.Minus;
import fr.inria.diverse.logo.expression.binary.Mult;
import fr.inria.diverse.logo.expression.binary.Plus;
import fr.inria.diverse.logo.expression.constant.BoolValue;
import fr.inria.diverse.logo.expression.constant.ConstantPackage;
import fr.inria.diverse.logo.expression.constant.IntValue;
import fr.inria.diverse.logo.expression.extended.And;
import fr.inria.diverse.logo.expression.extended.ExtendedPackage;
import fr.inria.diverse.logo.expression.extended.Or;
import fr.inria.diverse.logo.expression.unary.Not;
import fr.inria.diverse.logo.expression.unary.Opposite;
import fr.inria.diverse.logo.expression.unary.UnaryPackage;
import fr.inria.diverse.logo.statement.Block;
import fr.inria.diverse.logo.statement.Forward;
import fr.inria.diverse.logo.statement.Left;
import fr.inria.diverse.logo.statement.PenDown;
import fr.inria.diverse.logo.statement.PenUp;
import fr.inria.diverse.logo.statement.ProcedureCall;
import fr.inria.diverse.logo.statement.ProcedureDefinition;
import fr.inria.diverse.logo.statement.Right;
import fr.inria.diverse.logo.statement.StatementPackage;
import fr.inria.diverse.logo.statement.control.ControlPackage;
import fr.inria.diverse.logo.statement.control.If;
import fr.inria.diverse.logo.statement.control.Repeat;
import fr.inria.diverse.logo.statement.control.While;
import fr.inria.diverse.logo.xtext.services.LogoGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LogoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LogoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BinaryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BinaryPackage.DIV:
				sequence_MultDiv(context, (Div) semanticObject); 
				return; 
			case BinaryPackage.EQUALS:
				sequence_EqualsGreaterLower(context, (Equals) semanticObject); 
				return; 
			case BinaryPackage.GREATER:
				sequence_EqualsGreaterLower(context, (Greater) semanticObject); 
				return; 
			case BinaryPackage.LOWER:
				sequence_EqualsGreaterLower(context, (Lower) semanticObject); 
				return; 
			case BinaryPackage.MINUS:
				sequence_PlusMinus(context, (Minus) semanticObject); 
				return; 
			case BinaryPackage.MULT:
				sequence_MultDiv(context, (Mult) semanticObject); 
				return; 
			case BinaryPackage.PLUS:
				sequence_PlusMinus(context, (Plus) semanticObject); 
				return; 
			}
		else if (epackage == ConstantPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ConstantPackage.BOOL_VALUE:
				sequence_BoolValue(context, (BoolValue) semanticObject); 
				return; 
			case ConstantPackage.INT_VALUE:
				sequence_IntValue(context, (IntValue) semanticObject); 
				return; 
			}
		else if (epackage == ControlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ControlPackage.IF:
				if (rule == grammarAccess.getIfElseRule()) {
					sequence_IfElse(context, (If) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfRule()) {
					sequence_If(context, (If) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getControlStatementRule()) {
					sequence_If_IfElse(context, (If) semanticObject); 
					return; 
				}
				else break;
			case ControlPackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case ControlPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionPackage.VARIABLE_READ:
				sequence_VariableRead(context, (VariableRead) semanticObject); 
				return; 
			}
		else if (epackage == ExtendedPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExtendedPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ExtendedPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			}
		else if (epackage == LogoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LogoPackage.LOGO:
				sequence_Logo(context, (Logo) semanticObject); 
				return; 
			case LogoPackage.PARAMETER:
				sequence_Parameter(context, (fr.inria.diverse.logo.Parameter) semanticObject); 
				return; 
			}
		else if (epackage == StatementPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case StatementPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case StatementPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case StatementPackage.PEN_DOWN:
				sequence_PenDown(context, (PenDown) semanticObject); 
				return; 
			case StatementPackage.PEN_UP:
				sequence_PenUp(context, (PenUp) semanticObject); 
				return; 
			case StatementPackage.PROCEDURE_CALL:
				sequence_ProcedureCall(context, (ProcedureCall) semanticObject); 
				return; 
			case StatementPackage.PROCEDURE_DEFINITION:
				sequence_ProcedureDefinition(context, (ProcedureDefinition) semanticObject); 
				return; 
			case StatementPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			}
		else if (epackage == UnaryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UnaryPackage.NOT:
				sequence_NotOpposite(context, (Not) semanticObject); 
				return; 
			case UnaryPackage.OPPOSITE:
				sequence_NotOpposite(context, (Opposite) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     ExtendedExpression returns And
	 *     And returns And
	 *     EqualsGreaterLower returns And
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns And
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns And
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns And
	 *     PlusMinus returns And
	 *     PlusMinus.Plus_1_0_0_0_0 returns And
	 *     PlusMinus.Minus_1_0_0_1_0 returns And
	 *     MultDiv returns And
	 *     MultDiv.Mult_1_0_0_0 returns And
	 *     MultDiv.Div_1_0_1_0 returns And
	 *     NotOpposite returns And
	 *
	 * Constraint:
	 *     (expressions+=EqualsGreaterLower expressions+=EqualsGreaterLower+)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolValue
	 *     Constant returns BoolValue
	 *     EqualsGreaterLower returns BoolValue
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns BoolValue
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns BoolValue
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns BoolValue
	 *     PlusMinus returns BoolValue
	 *     PlusMinus.Plus_1_0_0_0_0 returns BoolValue
	 *     PlusMinus.Minus_1_0_0_1_0 returns BoolValue
	 *     MultDiv returns BoolValue
	 *     MultDiv.Mult_1_0_0_0 returns BoolValue
	 *     MultDiv.Div_1_0_1_0 returns BoolValue
	 *     NotOpposite returns BoolValue
	 *     BoolValue returns BoolValue
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BoolValue(ISerializationContext context, BoolValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equals
	 *     EqualsGreaterLower returns Equals
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Equals
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Equals
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Equals
	 *     PlusMinus returns Equals
	 *     PlusMinus.Plus_1_0_0_0_0 returns Equals
	 *     PlusMinus.Minus_1_0_0_1_0 returns Equals
	 *     MultDiv returns Equals
	 *     MultDiv.Mult_1_0_0_0 returns Equals
	 *     MultDiv.Div_1_0_1_0 returns Equals
	 *     NotOpposite returns Equals
	 *
	 * Constraint:
	 *     (leftExpression=EqualsGreaterLower_Equals_1_0_0_0 rightExpression=PlusMinus)
	 */
	protected void sequence_EqualsGreaterLower(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getEqualsLeftExpressionAction_1_0_0_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getRightExpressionPlusMinusParserRuleCall_1_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Greater
	 *     EqualsGreaterLower returns Greater
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Greater
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Greater
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Greater
	 *     PlusMinus returns Greater
	 *     PlusMinus.Plus_1_0_0_0_0 returns Greater
	 *     PlusMinus.Minus_1_0_0_1_0 returns Greater
	 *     MultDiv returns Greater
	 *     MultDiv.Mult_1_0_0_0 returns Greater
	 *     MultDiv.Div_1_0_1_0 returns Greater
	 *     NotOpposite returns Greater
	 *
	 * Constraint:
	 *     (leftExpression=EqualsGreaterLower_Greater_1_0_1_0 rightExpression=PlusMinus)
	 */
	protected void sequence_EqualsGreaterLower(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getGreaterLeftExpressionAction_1_0_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getRightExpressionPlusMinusParserRuleCall_1_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Lower
	 *     EqualsGreaterLower returns Lower
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Lower
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Lower
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Lower
	 *     PlusMinus returns Lower
	 *     PlusMinus.Plus_1_0_0_0_0 returns Lower
	 *     PlusMinus.Minus_1_0_0_1_0 returns Lower
	 *     MultDiv returns Lower
	 *     MultDiv.Mult_1_0_0_0 returns Lower
	 *     MultDiv.Div_1_0_1_0 returns Lower
	 *     NotOpposite returns Lower
	 *
	 * Constraint:
	 *     (leftExpression=EqualsGreaterLower_Lower_1_0_2_0 rightExpression=PlusMinus)
	 */
	protected void sequence_EqualsGreaterLower(ISerializationContext context, Lower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getLowerLeftExpressionAction_1_0_2_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getEqualsGreaterLowerAccess().getRightExpressionPlusMinusParserRuleCall_1_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Forward
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     step=Expression
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.FORWARD__STEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.FORWARD__STEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForwardAccess().getStepExpressionParserRuleCall_1_0(), semanticObject.getStep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfElse returns If
	 *
	 * Constraint:
	 *     ((condition=Expression | condition=Expression) ifBlock=Block elseBlock=Block)
	 */
	protected void sequence_IfElse(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     If returns If
	 *
	 * Constraint:
	 *     ((condition=Expression | condition=Expression) ifBlock=Block)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns If
	 *     ControlStatement returns If
	 *
	 * Constraint:
	 *     (((condition=Expression | condition=Expression) ifBlock=Block) | ((condition=Expression | condition=Expression) ifBlock=Block elseBlock=Block))
	 */
	protected void sequence_If_IfElse(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntValue
	 *     Constant returns IntValue
	 *     EqualsGreaterLower returns IntValue
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns IntValue
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns IntValue
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns IntValue
	 *     PlusMinus returns IntValue
	 *     PlusMinus.Plus_1_0_0_0_0 returns IntValue
	 *     PlusMinus.Minus_1_0_0_1_0 returns IntValue
	 *     MultDiv returns IntValue
	 *     MultDiv.Mult_1_0_0_0 returns IntValue
	 *     MultDiv.Div_1_0_1_0 returns IntValue
	 *     NotOpposite returns IntValue
	 *     IntValue returns IntValue
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntValue(ISerializationContext context, IntValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ConstantPackage.Literals.INT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ConstantPackage.Literals.INT_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Left
	 *     Left returns Left
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.LEFT__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.LEFT__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Logo returns Logo
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Logo(ISerializationContext context, Logo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     EqualsGreaterLower returns Div
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Div
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Div
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Div
	 *     PlusMinus returns Div
	 *     PlusMinus.Plus_1_0_0_0_0 returns Div
	 *     PlusMinus.Minus_1_0_0_1_0 returns Div
	 *     MultDiv returns Div
	 *     MultDiv.Mult_1_0_0_0 returns Div
	 *     MultDiv.Div_1_0_1_0 returns Div
	 *     NotOpposite returns Div
	 *
	 * Constraint:
	 *     (leftExpression=MultDiv_Div_1_0_1_0 rightExpression=NotOpposite)
	 */
	protected void sequence_MultDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivAccess().getDivLeftExpressionAction_1_0_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getMultDivAccess().getRightExpressionNotOppositeParserRuleCall_1_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Mult
	 *     EqualsGreaterLower returns Mult
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Mult
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Mult
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Mult
	 *     PlusMinus returns Mult
	 *     PlusMinus.Plus_1_0_0_0_0 returns Mult
	 *     PlusMinus.Minus_1_0_0_1_0 returns Mult
	 *     MultDiv returns Mult
	 *     MultDiv.Mult_1_0_0_0 returns Mult
	 *     MultDiv.Div_1_0_1_0 returns Mult
	 *     NotOpposite returns Mult
	 *
	 * Constraint:
	 *     (leftExpression=MultDiv_Mult_1_0_0_0 rightExpression=NotOpposite)
	 */
	protected void sequence_MultDiv(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultDivAccess().getMultLeftExpressionAction_1_0_0_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getMultDivAccess().getRightExpressionNotOppositeParserRuleCall_1_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     EqualsGreaterLower returns Not
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Not
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Not
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Not
	 *     PlusMinus returns Not
	 *     PlusMinus.Plus_1_0_0_0_0 returns Not
	 *     PlusMinus.Minus_1_0_0_1_0 returns Not
	 *     MultDiv returns Not
	 *     MultDiv.Mult_1_0_0_0 returns Not
	 *     MultDiv.Div_1_0_1_0 returns Not
	 *     NotOpposite returns Not
	 *
	 * Constraint:
	 *     expression=NotOpposite
	 */
	protected void sequence_NotOpposite(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotOppositeAccess().getExpressionNotOppositeParserRuleCall_3_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Opposite
	 *     EqualsGreaterLower returns Opposite
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Opposite
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Opposite
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Opposite
	 *     PlusMinus returns Opposite
	 *     PlusMinus.Plus_1_0_0_0_0 returns Opposite
	 *     PlusMinus.Minus_1_0_0_1_0 returns Opposite
	 *     MultDiv returns Opposite
	 *     MultDiv.Mult_1_0_0_0 returns Opposite
	 *     MultDiv.Div_1_0_1_0 returns Opposite
	 *     NotOpposite returns Opposite
	 *
	 * Constraint:
	 *     expression=NotOpposite
	 */
	protected void sequence_NotOpposite(ISerializationContext context, Opposite semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotOppositeAccess().getExpressionNotOppositeParserRuleCall_4_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     ExtendedExpression returns Or
	 *     Or returns Or
	 *     EqualsGreaterLower returns Or
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Or
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Or
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Or
	 *     PlusMinus returns Or
	 *     PlusMinus.Plus_1_0_0_0_0 returns Or
	 *     PlusMinus.Minus_1_0_0_1_0 returns Or
	 *     MultDiv returns Or
	 *     MultDiv.Mult_1_0_0_0 returns Or
	 *     MultDiv.Div_1_0_1_0 returns Or
	 *     NotOpposite returns Or
	 *
	 * Constraint:
	 *     (expressions+=EqualsGreaterLower expressions+=EqualsGreaterLower+)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.inria.diverse.logo.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LogoPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LogoPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PenDown
	 *     PenDown returns PenDown
	 *
	 * Constraint:
	 *     {PenDown}
	 */
	protected void sequence_PenDown(ISerializationContext context, PenDown semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PenUp
	 *     PenUp returns PenUp
	 *
	 * Constraint:
	 *     {PenUp}
	 */
	protected void sequence_PenUp(ISerializationContext context, PenUp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     EqualsGreaterLower returns Minus
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Minus
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Minus
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Minus
	 *     PlusMinus returns Minus
	 *     PlusMinus.Plus_1_0_0_0_0 returns Minus
	 *     PlusMinus.Minus_1_0_0_1_0 returns Minus
	 *     MultDiv returns Minus
	 *     MultDiv.Mult_1_0_0_0 returns Minus
	 *     MultDiv.Div_1_0_1_0 returns Minus
	 *     NotOpposite returns Minus
	 *
	 * Constraint:
	 *     (leftExpression=PlusMinus_Minus_1_0_0_1_0 rightExpression=MultDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getMinusLeftExpressionAction_1_0_0_1_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightExpressionMultDivParserRuleCall_1_0_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     EqualsGreaterLower returns Plus
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns Plus
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns Plus
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns Plus
	 *     PlusMinus returns Plus
	 *     PlusMinus.Plus_1_0_0_0_0 returns Plus
	 *     PlusMinus.Minus_1_0_0_1_0 returns Plus
	 *     MultDiv returns Plus
	 *     MultDiv.Mult_1_0_0_0 returns Plus
	 *     MultDiv.Div_1_0_1_0 returns Plus
	 *     NotOpposite returns Plus
	 *
	 * Constraint:
	 *     (leftExpression=PlusMinus_Plus_1_0_0_0_0 rightExpression=MultDiv)
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__LEFT_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BINARY_EXPRESSION__RIGHT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusMinusAccess().getPlusLeftExpressionAction_1_0_0_0_0(), semanticObject.getLeftExpression());
		feeder.accept(grammarAccess.getPlusMinusAccess().getRightExpressionMultDivParserRuleCall_1_0_1_0(), semanticObject.getRightExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ProcedureCall
	 *     ProcedureCall returns ProcedureCall
	 *
	 * Constraint:
	 *     (definition=[ProcedureDefinition|ID] parameterValues+=Expression*)
	 */
	protected void sequence_ProcedureCall(ISerializationContext context, ProcedureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ProcedureDefinition
	 *     ProcedureDefinition returns ProcedureDefinition
	 *
	 * Constraint:
	 *     (name=ID parameters+=Parameter* statements+=Statement+)
	 */
	protected void sequence_ProcedureDefinition(ISerializationContext context, ProcedureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Repeat
	 *     ControlStatement returns Repeat
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     (condition=Expression block=Block)
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.CONTROL_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.CONTROL_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ControlPackage.Literals.REPEAT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ControlPackage.Literals.REPEAT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getRepeatAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.RIGHT__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.RIGHT__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAccess().getAngleExpressionParserRuleCall_1_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableRead
	 *     EqualsGreaterLower returns VariableRead
	 *     EqualsGreaterLower.Equals_1_0_0_0 returns VariableRead
	 *     EqualsGreaterLower.Greater_1_0_1_0 returns VariableRead
	 *     EqualsGreaterLower.Lower_1_0_2_0 returns VariableRead
	 *     PlusMinus returns VariableRead
	 *     PlusMinus.Plus_1_0_0_0_0 returns VariableRead
	 *     PlusMinus.Minus_1_0_0_1_0 returns VariableRead
	 *     MultDiv returns VariableRead
	 *     MultDiv.Mult_1_0_0_0 returns VariableRead
	 *     MultDiv.Div_1_0_1_0 returns VariableRead
	 *     NotOpposite returns VariableRead
	 *     VariableRead returns VariableRead
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VariableRead(ISerializationContext context, VariableRead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.VARIABLE_READ__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.VARIABLE_READ__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReadAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns While
	 *     ControlStatement returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     ((condition=Expression | condition=Expression) block=Block)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
