// automatically generated by Xtext
grammar fr.inria.diverse.logo.xtext.Logo with org.eclipse.xtext.common.Terminals

import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore" as logo
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//value" as value
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//expression/constant" as constant
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//statement" as statement
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//expression/extended" as extended
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//symbol" as symbol
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//expression" as expression
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//statement/control" as control
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//expression/binary" as binary
import "platform:/resource/fr.inria.diverse.logo.model/model/logo.ecore#//expression/unary" as unary

Logo returns logo::Logo:
	(statements+=Statement)+;

Parameter returns logo::Parameter:
	':' name=ID;

Statement returns logo::Statement:
	Right | Left | Forward | PenDown | PenUp | ProcedureDefinition | ProcedureCall | ControlStatement | Block;

Expression returns logo::Expression:
	EqualsGreaterLower | ExtendedExpression;

ExtendedExpression returns expression::ExtendedExpression:
	Or | And;

Constant returns expression::Constant:
	IntValue | BoolValue;

Right returns statement::Right:
	'right' angle=Expression;

Left returns statement::Left:
	'left' angle=Expression;

Forward returns statement::Forward:
	'forward' step=Expression;

PenDown returns statement::PenDown:
	{statement::PenDown}
	'pendown';

PenUp returns statement::PenUp:
	{statement::PenUp}
	'penup';
	
ProcedureDefinition returns statement::ProcedureDefinition:
	'to' name=ID (parameters+=Parameter)* (statements+=Statement)+ 'end';

ProcedureCall returns statement::ProcedureCall:
	definition=[statement::ProcedureDefinition] (parameterValues+=Expression)*;

Block returns statement::Block:
	'[' (statements+=Statement)+ ']';

ControlStatement returns statement::ControlStatement:
	If | IfElse | While | Repeat;
	
If returns control::If:
	'if' (condition=Expression | '[' condition=Expression ']') ifBlock=Block;
	
IfElse returns control::If:
	'ifelse' (condition=Expression | '[' condition=Expression ']') ifBlock=Block elseBlock=Block;

While returns control::While:
	'while' (condition=Expression | '[' condition=Expression ']') block=Block;

Repeat returns control::Repeat:
	'repeat' condition=Expression block=Block;
	
And returns extended::And:
	'and' expressions+=EqualsGreaterLower =>(expressions+=EqualsGreaterLower)+;

Or returns extended::Or:
	'or' expressions+=EqualsGreaterLower =>(expressions+=EqualsGreaterLower)+;

EqualsGreaterLower returns logo::Expression:
	PlusMinus (({binary::Equals.leftExpression=current} '='
		| {binary::Greater.leftExpression=current} '>'
		| {binary::Lower.leftExpression=current} '<')
	rightExpression=PlusMinus)*;
		
PlusMinus returns logo::Expression:
	MultDiv =>(({binary::Plus.leftExpression=current} '+'
		| {binary::Minus.leftExpression=current} '-')
	rightExpression=MultDiv)*;
	
MultDiv returns logo::Expression:
	NotOpposite (({binary::Mult.leftExpression=current} '*'
		| {binary::Div.leftExpression=current} '/')
	rightExpression=NotOpposite)*;
	
NotOpposite returns logo::Expression:
	Constant | VariableRead | '(' Expression ')' | {unary::Not} 'not' expression=NotOpposite | {unary::Opposite} '-' expression=NotOpposite;

VariableRead returns expression::VariableRead:
	':' name=ID;

IntValue returns constant::IntValue:
	value=INT;

BoolValue returns constant::BoolValue:
	{constant::BoolValue} (value?='true' | 'false');
