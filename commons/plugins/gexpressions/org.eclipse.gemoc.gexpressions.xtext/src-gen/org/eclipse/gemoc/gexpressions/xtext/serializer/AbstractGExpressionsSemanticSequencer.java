/*
 * generated by Xtext
 */
package org.eclipse.gemoc.gexpressions.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gemoc.gexpressions.GAdditionExpression;
import org.eclipse.gemoc.gexpressions.GAndExpression;
import org.eclipse.gemoc.gexpressions.GBooleanExpression;
import org.eclipse.gemoc.gexpressions.GBraceExpression;
import org.eclipse.gemoc.gexpressions.GDoubleExpression;
import org.eclipse.gemoc.gexpressions.GEnumLiteralExpression;
import org.eclipse.gemoc.gexpressions.GEqualityExpression;
import org.eclipse.gemoc.gexpressions.GIfExpression;
import org.eclipse.gemoc.gexpressions.GImportStatement;
import org.eclipse.gemoc.gexpressions.GIntegerExpression;
import org.eclipse.gemoc.gexpressions.GMultiplicationExpression;
import org.eclipse.gemoc.gexpressions.GNavigationExpression;
import org.eclipse.gemoc.gexpressions.GNegationExpression;
import org.eclipse.gemoc.gexpressions.GOrExpression;
import org.eclipse.gemoc.gexpressions.GProgram;
import org.eclipse.gemoc.gexpressions.GReferenceExpression;
import org.eclipse.gemoc.gexpressions.GRelationExpression;
import org.eclipse.gemoc.gexpressions.GStringExpression;
import org.eclipse.gemoc.gexpressions.GXorExpression;
import org.eclipse.gemoc.gexpressions.GexpressionsPackage;
import org.eclipse.gemoc.gexpressions.xtext.services.GExpressionsGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractGExpressionsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GExpressionsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GexpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GexpressionsPackage.GADDITION_EXPRESSION:
				sequence_GAdditionExpression(context, (GAdditionExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GAND_EXPRESSION:
				sequence_GAndExpression(context, (GAndExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GBOOLEAN_EXPRESSION:
				sequence_GBooleanExpression(context, (GBooleanExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GBRACE_EXPRESSION:
				sequence_GBraceExpression(context, (GBraceExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GDOUBLE_EXPRESSION:
				sequence_GDoubleExpression(context, (GDoubleExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GENUM_LITERAL_EXPRESSION:
				sequence_GEnumLiteralExpression(context, (GEnumLiteralExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GEQUALITY_EXPRESSION:
				sequence_GEqualityExpression(context, (GEqualityExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GIF_EXPRESSION:
				sequence_GIfExpression(context, (GIfExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GIMPORT_STATEMENT:
				sequence_GImportStatement(context, (GImportStatement) semanticObject); 
				return; 
			case GexpressionsPackage.GINTEGER_EXPRESSION:
				sequence_GIntegerExpression(context, (GIntegerExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GMULTIPLICATION_EXPRESSION:
				sequence_GMultiplicationExpression(context, (GMultiplicationExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GNAVIGATION_EXPRESSION:
				sequence_GNavigationExpression(context, (GNavigationExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GNEGATION_EXPRESSION:
				sequence_GNegationExpression(context, (GNegationExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GOR_EXPRESSION:
				sequence_GOrExpression(context, (GOrExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GPROGRAM:
				sequence_GProgram(context, (GProgram) semanticObject); 
				return; 
			case GexpressionsPackage.GREFERENCE_EXPRESSION:
				sequence_GReferenceExpression(context, (GReferenceExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GRELATION_EXPRESSION:
				sequence_GRelationExpression(context, (GRelationExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GSTRING_EXPRESSION:
				sequence_GStringExpression(context, (GStringExpression) semanticObject); 
				return; 
			case GexpressionsPackage.GXOR_EXPRESSION:
				sequence_GXorExpression(context, (GXorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     GExpression returns GAdditionExpression
	 *     GOrExpression returns GAdditionExpression
	 *     GOrExpression.GOrExpression_1_0 returns GAdditionExpression
	 *     GXorExpression returns GAdditionExpression
	 *     GXorExpression.GXorExpression_1_0 returns GAdditionExpression
	 *     GAndExpression returns GAdditionExpression
	 *     GAndExpression.GAndExpression_1_0 returns GAdditionExpression
	 *     GEqualityExpression returns GAdditionExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GAdditionExpression
	 *     GRelationExpression returns GAdditionExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GAdditionExpression
	 *     GAdditionExpression returns GAdditionExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GAdditionExpression
	 *
	 * Constraint:
	 *     (leftOperand=GAdditionExpression_GAdditionExpression_1_0 operator=GAdditionOperator rightOperand=GMultiplicationExpression)
	 */
	protected void sequence_GAdditionExpression(ISerializationContext context, GAdditionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GADDITION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GADDITION_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGAdditionExpressionAccess().getGAdditionExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGAdditionExpressionAccess().getOperatorGAdditionOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGAdditionExpressionAccess().getRightOperandGMultiplicationExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GAndExpression
	 *     GOrExpression returns GAndExpression
	 *     GOrExpression.GOrExpression_1_0 returns GAndExpression
	 *     GXorExpression returns GAndExpression
	 *     GXorExpression.GXorExpression_1_0 returns GAndExpression
	 *     GAndExpression returns GAndExpression
	 *     GAndExpression.GAndExpression_1_0 returns GAndExpression
	 *
	 * Constraint:
	 *     (leftOperand=GAndExpression_GAndExpression_1_0 operator=GAndOperator rightOperand=GEqualityExpression)
	 */
	protected void sequence_GAndExpression(ISerializationContext context, GAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GAND_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GAND_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGAndExpressionAccess().getGAndExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGAndExpressionAccess().getOperatorGAndOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGAndExpressionAccess().getRightOperandGEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GBooleanExpression
	 *     GOrExpression returns GBooleanExpression
	 *     GOrExpression.GOrExpression_1_0 returns GBooleanExpression
	 *     GXorExpression returns GBooleanExpression
	 *     GXorExpression.GXorExpression_1_0 returns GBooleanExpression
	 *     GAndExpression returns GBooleanExpression
	 *     GAndExpression.GAndExpression_1_0 returns GBooleanExpression
	 *     GEqualityExpression returns GBooleanExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GBooleanExpression
	 *     GRelationExpression returns GBooleanExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GBooleanExpression
	 *     GAdditionExpression returns GBooleanExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GBooleanExpression
	 *     GMultiplicationExpression returns GBooleanExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GBooleanExpression
	 *     GNegationExpression returns GBooleanExpression
	 *     GNavigationExpression returns GBooleanExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GBooleanExpression
	 *     GReferenceExpression returns GBooleanExpression
	 *     GPrimaryExpression returns GBooleanExpression
	 *     GBooleanExpression returns GBooleanExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_GBooleanExpression(ISerializationContext context, GBooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBOOLEAN_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBOOLEAN_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGBooleanExpressionAccess().getValueBOOLEANTerminalRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GBraceExpression
	 *     GOrExpression returns GBraceExpression
	 *     GOrExpression.GOrExpression_1_0 returns GBraceExpression
	 *     GXorExpression returns GBraceExpression
	 *     GXorExpression.GXorExpression_1_0 returns GBraceExpression
	 *     GAndExpression returns GBraceExpression
	 *     GAndExpression.GAndExpression_1_0 returns GBraceExpression
	 *     GEqualityExpression returns GBraceExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GBraceExpression
	 *     GRelationExpression returns GBraceExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GBraceExpression
	 *     GAdditionExpression returns GBraceExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GBraceExpression
	 *     GMultiplicationExpression returns GBraceExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GBraceExpression
	 *     GNegationExpression returns GBraceExpression
	 *     GNavigationExpression returns GBraceExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GBraceExpression
	 *     GReferenceExpression returns GBraceExpression
	 *     GPrimaryExpression returns GBraceExpression
	 *     GBraceExpression returns GBraceExpression
	 *
	 * Constraint:
	 *     innerExpression=GExpression
	 */
	protected void sequence_GBraceExpression(ISerializationContext context, GBraceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBRACE_EXPRESSION__INNER_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBRACE_EXPRESSION__INNER_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGBraceExpressionAccess().getInnerExpressionGExpressionParserRuleCall_2_0(), semanticObject.getInnerExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GDoubleExpression
	 *     GOrExpression returns GDoubleExpression
	 *     GOrExpression.GOrExpression_1_0 returns GDoubleExpression
	 *     GXorExpression returns GDoubleExpression
	 *     GXorExpression.GXorExpression_1_0 returns GDoubleExpression
	 *     GAndExpression returns GDoubleExpression
	 *     GAndExpression.GAndExpression_1_0 returns GDoubleExpression
	 *     GEqualityExpression returns GDoubleExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GDoubleExpression
	 *     GRelationExpression returns GDoubleExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GDoubleExpression
	 *     GAdditionExpression returns GDoubleExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GDoubleExpression
	 *     GMultiplicationExpression returns GDoubleExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GDoubleExpression
	 *     GNegationExpression returns GDoubleExpression
	 *     GNavigationExpression returns GDoubleExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GDoubleExpression
	 *     GReferenceExpression returns GDoubleExpression
	 *     GPrimaryExpression returns GDoubleExpression
	 *     GNumericExpression returns GDoubleExpression
	 *     GDoubleExpression returns GDoubleExpression
	 *
	 * Constraint:
	 *     value=DOUBLE
	 */
	protected void sequence_GDoubleExpression(ISerializationContext context, GDoubleExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GDOUBLE_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GDOUBLE_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGDoubleExpressionAccess().getValueDOUBLETerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GEnumLiteralExpression
	 *     GOrExpression returns GEnumLiteralExpression
	 *     GOrExpression.GOrExpression_1_0 returns GEnumLiteralExpression
	 *     GXorExpression returns GEnumLiteralExpression
	 *     GXorExpression.GXorExpression_1_0 returns GEnumLiteralExpression
	 *     GAndExpression returns GEnumLiteralExpression
	 *     GAndExpression.GAndExpression_1_0 returns GEnumLiteralExpression
	 *     GEqualityExpression returns GEnumLiteralExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GEnumLiteralExpression
	 *     GRelationExpression returns GEnumLiteralExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GEnumLiteralExpression
	 *     GAdditionExpression returns GEnumLiteralExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GEnumLiteralExpression
	 *     GMultiplicationExpression returns GEnumLiteralExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GEnumLiteralExpression
	 *     GNegationExpression returns GEnumLiteralExpression
	 *     GNavigationExpression returns GEnumLiteralExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GEnumLiteralExpression
	 *     GReferenceExpression returns GEnumLiteralExpression
	 *     GPrimaryExpression returns GEnumLiteralExpression
	 *     GEnumLiteralExpression returns GEnumLiteralExpression
	 *
	 * Constraint:
	 *     value=[EEnumLiteral|QualifiedName]
	 */
	protected void sequence_GEnumLiteralExpression(ISerializationContext context, GEnumLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GENUM_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GENUM_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGEnumLiteralExpressionAccess().getValueEEnumLiteralQualifiedNameParserRuleCall_2_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GEqualityExpression
	 *     GOrExpression returns GEqualityExpression
	 *     GOrExpression.GOrExpression_1_0 returns GEqualityExpression
	 *     GXorExpression returns GEqualityExpression
	 *     GXorExpression.GXorExpression_1_0 returns GEqualityExpression
	 *     GAndExpression returns GEqualityExpression
	 *     GAndExpression.GAndExpression_1_0 returns GEqualityExpression
	 *     GEqualityExpression returns GEqualityExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GEqualityExpression
	 *
	 * Constraint:
	 *     (leftOperand=GEqualityExpression_GEqualityExpression_1_0 operator=GEqualityOperator rightOperand=GRelationExpression)
	 */
	protected void sequence_GEqualityExpression(ISerializationContext context, GEqualityExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GEQUALITY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GEQUALITY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGEqualityExpressionAccess().getGEqualityExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGEqualityExpressionAccess().getOperatorGEqualityOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGEqualityExpressionAccess().getRightOperandGRelationExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GIfExpression
	 *     GOrExpression returns GIfExpression
	 *     GOrExpression.GOrExpression_1_0 returns GIfExpression
	 *     GXorExpression returns GIfExpression
	 *     GXorExpression.GXorExpression_1_0 returns GIfExpression
	 *     GAndExpression returns GIfExpression
	 *     GAndExpression.GAndExpression_1_0 returns GIfExpression
	 *     GEqualityExpression returns GIfExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GIfExpression
	 *     GRelationExpression returns GIfExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GIfExpression
	 *     GAdditionExpression returns GIfExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GIfExpression
	 *     GMultiplicationExpression returns GIfExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GIfExpression
	 *     GNegationExpression returns GIfExpression
	 *     GNavigationExpression returns GIfExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GIfExpression
	 *     GReferenceExpression returns GIfExpression
	 *     GPrimaryExpression returns GIfExpression
	 *     GIfExpression returns GIfExpression
	 *
	 * Constraint:
	 *     (condition=GExpression thenExpression=GExpression elseExpression=GExpression)
	 */
	protected void sequence_GIfExpression(ISerializationContext context, GIfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GIF_EXPRESSION__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGIfExpressionAccess().getConditionGExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getGIfExpressionAccess().getThenExpressionGExpressionParserRuleCall_4_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getGIfExpressionAccess().getElseExpressionGExpressionParserRuleCall_6_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GImportStatement returns GImportStatement
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_GImportStatement(ISerializationContext context, GImportStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GIMPORT_STATEMENT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GIMPORT_STATEMENT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGImportStatementAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GIntegerExpression
	 *     GOrExpression returns GIntegerExpression
	 *     GOrExpression.GOrExpression_1_0 returns GIntegerExpression
	 *     GXorExpression returns GIntegerExpression
	 *     GXorExpression.GXorExpression_1_0 returns GIntegerExpression
	 *     GAndExpression returns GIntegerExpression
	 *     GAndExpression.GAndExpression_1_0 returns GIntegerExpression
	 *     GEqualityExpression returns GIntegerExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GIntegerExpression
	 *     GRelationExpression returns GIntegerExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GIntegerExpression
	 *     GAdditionExpression returns GIntegerExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GIntegerExpression
	 *     GMultiplicationExpression returns GIntegerExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GIntegerExpression
	 *     GNegationExpression returns GIntegerExpression
	 *     GNavigationExpression returns GIntegerExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GIntegerExpression
	 *     GReferenceExpression returns GIntegerExpression
	 *     GPrimaryExpression returns GIntegerExpression
	 *     GNumericExpression returns GIntegerExpression
	 *     GIntegerExpression returns GIntegerExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_GIntegerExpression(ISerializationContext context, GIntegerExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GINTEGER_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GINTEGER_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGIntegerExpressionAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GMultiplicationExpression
	 *     GOrExpression returns GMultiplicationExpression
	 *     GOrExpression.GOrExpression_1_0 returns GMultiplicationExpression
	 *     GXorExpression returns GMultiplicationExpression
	 *     GXorExpression.GXorExpression_1_0 returns GMultiplicationExpression
	 *     GAndExpression returns GMultiplicationExpression
	 *     GAndExpression.GAndExpression_1_0 returns GMultiplicationExpression
	 *     GEqualityExpression returns GMultiplicationExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GMultiplicationExpression
	 *     GRelationExpression returns GMultiplicationExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GMultiplicationExpression
	 *     GAdditionExpression returns GMultiplicationExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GMultiplicationExpression
	 *     GMultiplicationExpression returns GMultiplicationExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GMultiplicationExpression
	 *
	 * Constraint:
	 *     (leftOperand=GMultiplicationExpression_GMultiplicationExpression_1_0 operator=GMultiplicationOperator rightOperand=GNegationExpression)
	 */
	protected void sequence_GMultiplicationExpression(ISerializationContext context, GMultiplicationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GMULTIPLICATION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GMULTIPLICATION_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGMultiplicationExpressionAccess().getGMultiplicationExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGMultiplicationExpressionAccess().getOperatorGMultiplicationOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGMultiplicationExpressionAccess().getRightOperandGNegationExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GNavigationExpression
	 *     GOrExpression returns GNavigationExpression
	 *     GOrExpression.GOrExpression_1_0 returns GNavigationExpression
	 *     GXorExpression returns GNavigationExpression
	 *     GXorExpression.GXorExpression_1_0 returns GNavigationExpression
	 *     GAndExpression returns GNavigationExpression
	 *     GAndExpression.GAndExpression_1_0 returns GNavigationExpression
	 *     GEqualityExpression returns GNavigationExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GNavigationExpression
	 *     GRelationExpression returns GNavigationExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GNavigationExpression
	 *     GAdditionExpression returns GNavigationExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GNavigationExpression
	 *     GMultiplicationExpression returns GNavigationExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GNavigationExpression
	 *     GNegationExpression returns GNavigationExpression
	 *     GNavigationExpression returns GNavigationExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GNavigationExpression
	 *
	 * Constraint:
	 *     (body=GNavigationExpression_GNavigationExpression_1_0 referencedEObject=[EObject|ID])
	 */
	protected void sequence_GNavigationExpression(ISerializationContext context, GNavigationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GNAVIGATION_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GNAVIGATION_EXPRESSION__BODY));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GNAVIGATION_EXPRESSION__REFERENCED_EOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GNAVIGATION_EXPRESSION__REFERENCED_EOBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGNavigationExpressionAccess().getGNavigationExpressionBodyAction_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getGNavigationExpressionAccess().getReferencedEObjectEObjectIDTerminalRuleCall_1_2_0_1(), semanticObject.getReferencedEObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GNegationExpression
	 *     GOrExpression returns GNegationExpression
	 *     GOrExpression.GOrExpression_1_0 returns GNegationExpression
	 *     GXorExpression returns GNegationExpression
	 *     GXorExpression.GXorExpression_1_0 returns GNegationExpression
	 *     GAndExpression returns GNegationExpression
	 *     GAndExpression.GAndExpression_1_0 returns GNegationExpression
	 *     GEqualityExpression returns GNegationExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GNegationExpression
	 *     GRelationExpression returns GNegationExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GNegationExpression
	 *     GAdditionExpression returns GNegationExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GNegationExpression
	 *     GMultiplicationExpression returns GNegationExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GNegationExpression
	 *     GNegationExpression returns GNegationExpression
	 *
	 * Constraint:
	 *     (operator=GNegationOperator operand=GNavigationExpression)
	 */
	protected void sequence_GNegationExpression(ISerializationContext context, GNegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GNEGATION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GNEGATION_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GUNARY_OPERATOR_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GUNARY_OPERATOR_EXPRESSION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGNegationExpressionAccess().getOperatorGNegationOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGNegationExpressionAccess().getOperandGNavigationExpressionParserRuleCall_1_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GOrExpression
	 *     GOrExpression returns GOrExpression
	 *     GOrExpression.GOrExpression_1_0 returns GOrExpression
	 *
	 * Constraint:
	 *     (leftOperand=GOrExpression_GOrExpression_1_0 operator=GOrOperator rightOperand=GXorExpression)
	 */
	protected void sequence_GOrExpression(ISerializationContext context, GOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGOrExpressionAccess().getGOrExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGOrExpressionAccess().getOperatorGOrOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGOrExpressionAccess().getRightOperandGXorExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GProgram returns GProgram
	 *
	 * Constraint:
	 *     (imports+=GImportStatement+ | (imports+=GImportStatement+ expressions+=GExpression expressions+=GExpression*))?
	 */
	protected void sequence_GProgram(ISerializationContext context, GProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GReferenceExpression
	 *     GOrExpression returns GReferenceExpression
	 *     GOrExpression.GOrExpression_1_0 returns GReferenceExpression
	 *     GXorExpression returns GReferenceExpression
	 *     GXorExpression.GXorExpression_1_0 returns GReferenceExpression
	 *     GAndExpression returns GReferenceExpression
	 *     GAndExpression.GAndExpression_1_0 returns GReferenceExpression
	 *     GEqualityExpression returns GReferenceExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GReferenceExpression
	 *     GRelationExpression returns GReferenceExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GReferenceExpression
	 *     GAdditionExpression returns GReferenceExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GReferenceExpression
	 *     GMultiplicationExpression returns GReferenceExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GReferenceExpression
	 *     GNegationExpression returns GReferenceExpression
	 *     GNavigationExpression returns GReferenceExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GReferenceExpression
	 *     GReferenceExpression returns GReferenceExpression
	 *
	 * Constraint:
	 *     referencedEObject=[EObject|ID]
	 */
	protected void sequence_GReferenceExpression(ISerializationContext context, GReferenceExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GREFERENCE_EXPRESSION__REFERENCED_EOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GREFERENCE_EXPRESSION__REFERENCED_EOBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGReferenceExpressionAccess().getReferencedEObjectEObjectIDTerminalRuleCall_1_1_0_1(), semanticObject.getReferencedEObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GRelationExpression
	 *     GOrExpression returns GRelationExpression
	 *     GOrExpression.GOrExpression_1_0 returns GRelationExpression
	 *     GXorExpression returns GRelationExpression
	 *     GXorExpression.GXorExpression_1_0 returns GRelationExpression
	 *     GAndExpression returns GRelationExpression
	 *     GAndExpression.GAndExpression_1_0 returns GRelationExpression
	 *     GEqualityExpression returns GRelationExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GRelationExpression
	 *     GRelationExpression returns GRelationExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GRelationExpression
	 *
	 * Constraint:
	 *     (leftOperand=GRelationExpression_GRelationExpression_1_0 operator=GRelationOperator rightOperand=GAdditionExpression)
	 */
	protected void sequence_GRelationExpression(ISerializationContext context, GRelationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GRELATION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GRELATION_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGRelationExpressionAccess().getGRelationExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGRelationExpressionAccess().getOperatorGRelationOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGRelationExpressionAccess().getRightOperandGAdditionExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GStringExpression
	 *     GOrExpression returns GStringExpression
	 *     GOrExpression.GOrExpression_1_0 returns GStringExpression
	 *     GXorExpression returns GStringExpression
	 *     GXorExpression.GXorExpression_1_0 returns GStringExpression
	 *     GAndExpression returns GStringExpression
	 *     GAndExpression.GAndExpression_1_0 returns GStringExpression
	 *     GEqualityExpression returns GStringExpression
	 *     GEqualityExpression.GEqualityExpression_1_0 returns GStringExpression
	 *     GRelationExpression returns GStringExpression
	 *     GRelationExpression.GRelationExpression_1_0 returns GStringExpression
	 *     GAdditionExpression returns GStringExpression
	 *     GAdditionExpression.GAdditionExpression_1_0 returns GStringExpression
	 *     GMultiplicationExpression returns GStringExpression
	 *     GMultiplicationExpression.GMultiplicationExpression_1_0 returns GStringExpression
	 *     GNegationExpression returns GStringExpression
	 *     GNavigationExpression returns GStringExpression
	 *     GNavigationExpression.GNavigationExpression_1_0 returns GStringExpression
	 *     GReferenceExpression returns GStringExpression
	 *     GPrimaryExpression returns GStringExpression
	 *     GStringExpression returns GStringExpression
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_GStringExpression(ISerializationContext context, GStringExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GSTRING_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GSTRING_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGStringExpressionAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GXorExpression
	 *     GOrExpression returns GXorExpression
	 *     GOrExpression.GOrExpression_1_0 returns GXorExpression
	 *     GXorExpression returns GXorExpression
	 *     GXorExpression.GXorExpression_1_0 returns GXorExpression
	 *
	 * Constraint:
	 *     (leftOperand=GXorExpression_GXorExpression_1_0 operator=GXorOperator rightOperand=GAndExpression)
	 */
	protected void sequence_GXorExpression(ISerializationContext context, GXorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__LEFT_OPERAND));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GXOR_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GXOR_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GexpressionsPackage.Literals.GBINARY_OPERATOR_EXPRESSION__RIGHT_OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGXorExpressionAccess().getGXorExpressionLeftOperandAction_1_0(), semanticObject.getLeftOperand());
		feeder.accept(grammarAccess.getGXorExpressionAccess().getOperatorGXorOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getGXorExpressionAccess().getRightOperandGAndExpressionParserRuleCall_1_2_0(), semanticObject.getRightOperand());
		feeder.finish();
	}
	
	
}
